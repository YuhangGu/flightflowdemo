<!DOCTYPE html>
<meta charset="utf-8">
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Iceland Flight</title>
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <link href="../css/c3.css" rel="stylesheet" type="text/css">
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/d3/3.4.2/d3.js"></script>
    <script src="../js/d3.geo.projection.v0.min.js"></script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/c3/0.4.4/c3.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
    <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../js/d3.v3.js"></script>
    <script type="text/javascript" src="../js/canvasjs.min.js"></script>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="http://d3js.org/d3.geo.projection.v0.min.js" charset="utf-8"></script>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="../js/d3.geo.projection.v0.min.js"></script>
    <script src="http://d3js.org/topojson.v0.min.js"></script>
    <script src="//d3js.org/d3.v3.min.js"></script>
    <script src="//d3js.org/topojson.v1.min.js"></script>
</head>

<style>

    .land {
        fill: #f0f0f0;
        stroke: #444;
        stroke-width: .5px;
    }

    .map-overlay {
        font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        position: absolute;
        width: 50%;
        top: 0;
        left: 0;
        padding: 10px;
    }

    .map-overlay .map-overlay-inner {
        background-color: #fff;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.20);
        border-radius: 3px;
        padding: 10px;
        margin-bottom: 10px;
    }

    .map-overlay h2 {
        line-height: 8px;
        display: block;
        margin: 0 0 10px;
    }

    .map-overlay .legend .bar {
        height: 10px;
        display: inline-block;
    }

    .map-overlay input {
        background-color: transparent;
        display: inline-block;
        width: 100%;
        position: relative;
        margin: 0;
        cursor: ew-resize;
    }

</style>

<body style="padding-left: 10px;">

<div class="container-fluid main">
    <div class="row">
        <div class="col-xs-12 bg-none">

            <div class="row" id="toprow">
                <div class="col-xs-12">
                    <h2>Iceland Airline Flows</h2>
                </div>
            </div>

            <div class="row row-map" id="midrow">

                <div class="col-xs-12 col-sm-8">
                    <!-- Bootstrap-map-js -->
                    <div id="maincontainer">
                        <div id="map" align="center"></div>
                        <div class='map-overlay top'>
                            <div class='map-overlay-inner'>
                                <h2>Iceland flight 2004-2016</h2>
                                <label id='year'></label>
                                <input id='slider' type='range' min='0' max='23' step='1' value='0'/>
                            </div>
                        </div>

                    </div>
                </div>

                <div class="col-xs-12 col-sm-4">
                    <!--<h5>Left 4 (not fixed)</h5>-->
                    <div id="d3chord"></div>
                </div>

                <div class="row" id="bottomrow"></div>
            </div>

        </div>
    </div>
</div>


<script type="text/javascript">
    //Width and height
    var w = 960, h = 960;
    var formatC = d3.format(",.0f");
    var formatD = d3.format("+,.0f");


    var a = [-22.623408, 63.996136], // KEF, Iceland
            b = [-121.925906, 37.366695], // SJC, USA
            circle = d3.geo.circle();


    var projection = d3.geo.azimuthalEquidistant()
            .scale(150)
            .translate([w / 2, h / 2])
            .clipAngle(180 - 1e-3)
            .precision(.1);

    //Define path generator
    var path = d3.geo.path().projection(projection);

    var svg = d3.select("#map").append("svg")
            .attr("width", w)
            .attr("height", h).append("g")
            .attr("transform", "rotate(0,180,180)");

    var colors = ["#EDF8FB", "#41083e"];

    var immdomain = [98, 2184]; // min max total number immigrations
    var emmdomain = [146, 2062]; // min max total number emmigrations

    var circleSize = d3.scale.linear().range([0, 500]).domain([0, 5000]);

    var lineSize = d3.scale.linear().range([2, 10]).domain([0, 2500]);

    var fillcolor = d3.scale.linear().range(colors).domain(immdomain);

    //Create SVG element


    var zoom = d3.behavior.zoom()
            .translate([0, 0])
            .scale(1)
            .scaleExtent([1, 8])
            .on("zoom", zoomed);

    var fp = d3.format(".1f");

    //initialize html tooltip
    var tooltip = d3.select("#maincontainer")
            .append("div")
            .attr("id", "tt")
            .style("z-index", "10")
            .style("position", "absolute")
            .style("visibility", "hidden");

    var tooltip2 = d3.select("#maincontainer")
            .append("div")
            .attr("id", "tt2")
            .style("z-index", "10")
            .style("position", "absolute")
            .style("visibility", "hidden");

    var g_basemap = svg.append("g")
            .attr("class","basemap");

    var g_flows = svg.append("g")
            .attr("class","flow");

    var g_flowsArr = [];

    var i ;
    for( i = 0 ; i < 24; i++)
    {
        var gtemp = svg.append("g").attr("id", i.toString());
        g_flowsArr.push(gtemp);
    }

    //console.log("g_flowsArr",g_flowsArr);

    var color = d3.scale.quantize()
            .domain([0, 23])
            .range(["#FF0000","#0000FF"]);


    drawBaseMap();
    //drawAirports();

    drawAirLines( playAnimation );

    function playAnimation( ){


        for(var i = 0; i < 24; i ++)
        {
            //console.log("g_flowsArr[i]",i,g_flowsArr[i]);
            setTimeout(showthishour(i), 5000);

        }

    }


    function drawBaseMap() {

        d3.json("data/world-110m.json", function (error, world) {

            g_basemap.append("path", ".circle")
                    .datum(topojson.object(world, world.objects.land))
                    .attr("class", "land")
                    .attr("d", path);
        });

    }

    function drawAirports() {

        d3.json("data/airport.json", function (airports) {
            //console.log(airports);
            g.selectAll("circle")
                    .data(airports)
                    .enter()
                    .append("circle")
                    .attr("cx", function (d) {
                        return projection([d.longitude, d.latitude])[0];
                    })
                    .attr("cy", function (d) {
                        return projection([d.longitude, d.latitude])[1];
                    })
                    .attr("r", 1);
        });

    }

    function drawAirLines( callback ) {

        d3.json("data/timeandflow.json", function (flights) {

            flights.features.forEach(function (d) {

                var timestring = d.properties.deptime_1.substr(0,2);
                var index = parseInt(timestring, 10);
                var pathflow = g_flowsArr[index].append("path")
                        .attr("stroke", color(index))
                        .attr("stroke-width", 0.5)
                        .attr("fill", "none")
                        .attr("opacity", 0)
                        .attr("class", "flows")
                        .attr("d", function () {

                            return drawArcs(projection, d.geometry.coordinates);
                            // the origin function to draw arcs
                            /*
                            var dx = projection([d.geometry.coordinates[1][0], d.geometry.coordinates[1][1]])[0]
                                            - projection([d.geometry.coordinates[0][0], d.geometry.coordinates[0][1]])[0],
                                    dy = projection([d.geometry.coordinates[1][0], d.geometry.coordinates[1][1]])[1]
                                            - projection([d.geometry.coordinates[0][0], d.geometry.coordinates[0][1]])[1],
                                    dr = Math.sqrt(dx * dx + dy * dy);

                            if (dx < 0) {
                                return "M" + projection([d.geometry.coordinates[1][0], d.geometry.coordinates[1][1]])[0]
                                        + "," + projection([d.geometry.coordinates[1][0], d.geometry.coordinates[1][1]])[1]
                                        + "A" + dr + "," + dr +
                                        " 0 0,1 " + projection([d.geometry.coordinates[0][0], d.geometry.coordinates[0][1]])[0]
                                        + "," + projection([d.geometry.coordinates[0][0], d.geometry.coordinates[0][1]])[1];
                            }
                            else {
                                return "M" + projection([d.geometry.coordinates[0][0], d.geometry.coordinates[0][1]])[0]
                                        + "," + projection([d.geometry.coordinates[0][0], d.geometry.coordinates[0][1]])[1]
                                        + "A" + dr + "," + dr +
                                        " 0 0,1 " + projection([d.geometry.coordinates[1][0], d.geometry.coordinates[1][1]])[0]
                                        + "," + projection([d.geometry.coordinates[1][0], d.geometry.coordinates[1][1]])[1];
                            }
                            */


                        })
                        .on("mouseover", function (d, i) {
                            d3.select(this).attr("stroke", "#ffff00")
                                    .attr("stroke-width", 2)
                                    .attr("id", "lastselected");
                        })
                        .on("mouseout", function (d, i) {
                            d3.select("#lastselected").attr("stroke", "rgb(60,120,155)")
                                    .attr("stroke-width", 0.5)
                                    .attr("id", "flows");
                        });

            });
        });
        setTimeout(callback, 2000);
    }

    function zoomed() {
        g.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
        g.select(".state").style("stroke-width", 1 / d3.event.scale);
        g.select(".flows").style("stroke-width", 1 / d3.event.scale);
    }

    document.getElementById('slider').addEventListener('input', function (e) {
        var hour = parseInt(e.target.value, 10);
        showthishour(hour);
    });

    function showthishour(i){

        svg.selectAll('.flows').attr('opacity',0);

        g_flowsArr[i].selectAll("path").transition()
                .duration(2000)
                .attr('opacity',0.55);

    }

    function drawArcs(projection, arr)
    {
        var point_0_x, point_0_y,
                point_1_x,point_1_y,
                point_2_x,point_2_y;

        //console.log(arr.length);
        if (arr.length == 2)
        {
            point_0_x = arr[0][0];
            point_0_y = arr[0][1];
            point_1_x = arr[1][0];
            point_1_y = arr[1][1];
            var dx = projection([point_1_x, point_1_y])[0]
                            - projection([point_0_x, point_0_y])[0],
                    dy = projection([point_1_x, point_1_y])[1]
                            - projection([point_0_x, point_0_y])[1],
                    dr = Math.sqrt(dx * dx + dy * dy);

            if (dx < 0) {
                return "M" + projection([point_1_x, point_1_y])[0]
                        + "," + projection([point_1_x, point_1_y])[1]
                        + "A" + dr + "," + dr +
                        " 0 0,1 " + projection([point_0_x, point_0_y])[0]
                        + "," + projection([point_0_x, point_0_y])[1];
            }
            else {
                return "M" + projection([point_0_x, point_0_y])[0]
                        + "," + projection([point_0_x, point_0_y])[1]
                        + "A" + dr + "," + dr +
                        " 0 0,1 " + projection([point_1_x, point_1_y])[0]
                        + "," + projection([point_1_x, point_1_y])[1];
            }

        }
        else if (arr.length == 3)
        {
            point_0_x = arr[0][0];
            point_0_y = arr[0][1];
            point_1_x = arr[1][0];
            point_1_y = arr[1][1];
            point_2_x = arr[2][0];
            point_2_y = arr[2][1];

            var dx = projection([point_1_x, point_1_y])[0]
                            - projection([point_0_x, point_0_y])[0],
                    dy = projection([point_1_x, point_1_y])[1]
                            - projection([point_0_x, point_0_y])[1],
                    dr = Math.sqrt(dx * dx + dy * dy);

            var dx_1 = projection([point_1_x, point_1_y])[0]
                            - projection([point_0_x, point_0_y])[0],
                    dy_1 = projection([point_1_x, point_1_y])[1]
                            - projection([point_0_x, point_0_y])[1],
                    dr_1 = Math.sqrt(dx_1 * dx_1 + dy_1 * dy_1);


            if (dx < 0) {
                return "M" + projection([point_1_x, point_1_y])[0]
                        + "," + projection([point_1_x, point_1_y])[1]
                        + "A" + dr + "," + dr +
                        " 0 0,1 " + projection([point_0_x, point_0_y])[0]
                        + "," + projection([point_0_x, point_0_y])[1]
                        + "M" + projection([point_2_x, point_2_y])[0]
                        + "," + projection([point_2_x, point_2_y])[1]
                        + "A" + dr_1 + "," + dr_1 +
                        " 0 0,1 " + projection([point_1_x, point_1_y])[0]
                        + "," + projection([point_1_x, point_1_y])[1];
            }
            else {
                return "M" + projection([point_0_x, point_0_y])[0]
                        + "," + projection([point_0_x, point_0_y])[1]
                        + "A" + dr + "," + dr +
                        " 0 0,1 " + projection([point_1_x, point_1_y])[0]
                        + "," + projection([point_1_x, point_1_y])[1];
            }

        }
        else
        {
            console.log("fuck, there musth be something worng");
        }




    }

    d3.select(self.frameElement).style("height", h + "px");

</script>

</body>
</html>